# Полное описание структуры языка программирования

## 1. ТИПЫ ДАННЫХ

### Базовые типы:
- **`number`** - целочисленный тип (short, диапазон: -32768 до 32767)
- **`line`** - строковый тип (максимальная длина: 255 символов)
- **`char`** - символьный тип (1 символ)
- **`proc`** - тип для функций без возвращаемого значения (void)

## 2. КЛЮЧЕВЫЕ СЛОВА

### Объявление переменных:
- **`new`** - ключевое слово для объявления переменных
  - Синтаксис: `new <тип> <имя> [= <значение>];`
  - Примеры:
    - `new number x;`
    - `new number y = 5;`
    - `new line str = "Hello";`
    - `new char ch = 'A';`

### Объявление функций:
- **`function`** - ключевое слово для объявления функции с возвращаемым значением
  - Синтаксис: `<тип> function <имя>(<параметры>)[<тело>]`
  - Пример: `number function max(number x, number y)[...]`

- **`proc function`** - ключевое слово для объявления функции без возвращаемого значения
  - Синтаксис: `proc function <имя>(<параметры>)[<тело>]`
  - Пример: `proc function stand(line a, line b)[...]`

### Точка входа:
- **`main`** - главная функция программы
  - Синтаксис: `main[<тело>]`

### Управление потоком:
- **`is:`** - начало условного оператора
- **`istrue`** - блок кода, выполняемый при истинном условии
- **`isfalse`** - блок кода, выполняемый при ложном условии
- **`do`** - начало цикла
- **`return`** - возврат значения из функции (для функций с типом) или завершение функции (для proc)

### Ввод-вывод:
- **`output`** - вывод значения на экран
- **`nextline`** - вывод символа новой строки

## 3. АРИФМЕТИЧЕСКИЕ ОПЕРАЦИИ

### Бинарные операции:
- **`+`** (LEX_PLUS) - сложение
- **`-`** (LEX_MINUS) - вычитание
- **`*`** (LEX_STAR) - умножение
- **`/`** (LEX_DIRSLASH) - деление
- **`%`** (LEX_PERSENT) - остаток от деления

### Приоритет операций:
1. Скобки `()` - наивысший приоритет
2. `*`, `/`, `%` - приоритет 2
3. `+`, `-` - приоритет 1

### Поддержка польской нотации:
- Арифметические выражения преобразуются в обратную польскую нотацию (RPN)
- Поддерживаются скобки для изменения порядка вычислений

## 4. ОПЕРАТОРЫ СРАВНЕНИЯ

Все операторы сравнения работают только с типом `number`:

- **`>`** (LEX_MORE) - больше
- **`<`** (LEX_LESS) - меньше
- **`&`** (LEX_EQUALS) - равно
- **`!`** (LEX_NOTEQUALS) - не равно
- **`~`** (LEX_MOREEQUALS) - больше или равно
- **`@`** (LEX_LESSEQUALS) - меньше или равно

## 5. УСЛОВНЫЕ ОПЕРАТОРЫ

### Синтаксис:
```
is: <выражение1> <оператор_сравнения> <выражение2> #
istrue [<блок_кода_при_истине>;]
isfalse [<блок_кода_при_лжи>;]#
```

### Пример:
```
is: x > y #
istrue [result = x;]
isfalse [result = y;]#
```

### Структура:
- `is:` - начало условия
- `<выражение1> <оператор> <выражение2>` - условие сравнения
- `#` - разделитель
- `istrue [...]` - блок при истинном условии
- `isfalse [...]` - блок при ложном условии
- `#` - конец условного оператора

## 6. ЦИКЛЫ

### Синтаксис:
```
is: <переменная> <оператор_сравнения> <значение> #
do [
    <тело_цикла>;
]#
```

### Пример:
```
new number ab = 10;
is: ab < 10 #
do [
    output ab;
    output " ";
    ab = ab + 2;
]#
```

### Особенности:
- Цикл выполняется пока условие истинно
- Условие проверяется перед каждой итерацией
- Внутри цикла можно изменять переменные из условия

## 7. ЛИТЕРАЛЫ

### Числовые литералы:
- **Десятичные**: `123`, `-45`, `0`
- **Шестнадцатеричные**: `0x4a`, `0xFF`, `-0x10`
  - Формат: `0x` или `0X` + шестнадцатеричные цифры (0-9, A-F, a-f)

### Строковые литералы:
- Формат: `"текст"`
- Примеры: `"Hello"`, `"Result: "`, `"False"`
- Максимальная длина: 255 символов
- Могут содержать пробелы, цифры, специальные символы

### Символьные литералы:
- Формат: `'символ'`
- Примеры: `'H'`, `'i'`, `'!'`
- Длина: строго 1 символ

## 8. СТАНДАРТНЫЕ ФУНКЦИИ

### `concat(line a, line b)` → `line`
- Объединяет две строки
- Параметры: 2 строки
- Возвращает: объединенную строку

### `compare(line a, line b)` → `number`
- Сравнивает две строки
- Параметры: 2 строки
- Возвращает: число (1 если строки равны, иначе другое значение)

### `rnd(number min, number max)` → `number`
- Генерирует случайное число в диапазоне
- Параметры: минимальное и максимальное значение
- Возвращает: случайное число в указанном диапазоне

### `aton(line str)` → `number`
- Преобразует строку в число
- Параметры: 1 строка (содержащая число)
- Возвращает: числовое значение строки

### `slength(line str)` → `number`
- Возвращает длину строки
- Параметры: 1 строка
- Возвращает: длину строки (число)

## 9. ОПЕРАТОР ПРИСВАИВАНИЯ

- **`=`** (LEX_EQUAL) - присваивание значения
- Синтаксис: `<переменная> = <выражение>;`
- Поддерживает арифметические выражения
- Поддерживает вызовы функций
- Типы левой и правой части должны совпадать

### Примеры:
```
new number x;
x = 5;
x = y + z * 2;
x = max(a, b);
```

## 10. РАЗДЕЛИТЕЛИ И СИМВОЛЫ

### Разделители:
- **`;`** (LEX_SEPARATOR) - конец инструкции
- **`,`** (LEX_COMMA) - разделитель параметров
- **`#`** (LEX_DIEZ) - разделитель в условных операторах и циклах

### Скобки:
- **`[`** (LEX_LEFTBRACE) - открывающая квадратная скобка (начало блока)
- **`]`** (LEX_BRACELET) - закрывающая квадратная скобка (конец блока)
- **`(`** (LEX_LEFTHESIS) - открывающая круглая скобка
- **`)`** (LEX_RIGHTTHESIS) - закрывающая круглая скобка

### Специальные символы:
- **`{`** - открывающая фигурная скобка
- **`}`** - закрывающая фигурная скобка

## 10.1. КОММЕНТАРИИ

Язык поддерживает два типа комментариев, которые полностью игнорируются компилятором:

### Однострочные комментарии:
- **`//`** - комментарий до конца строки
- Все символы после `//` до конца строки игнорируются
- Пример:
  ```
  new number x = 5;  // Это комментарий
  output x;  // Вывод переменной
  ```

### Многострочные комментарии:
- **`/* */`** - комментарий между маркерами
- Может охватывать несколько строк
- Пример:
  ```
  /* 
   * Это многострочный комментарий
   * Он может содержать несколько строк
   */
  new number y = 10;
  ```
  
  Или в одной строке:
  ```
  new number z = 15; /* комментарий в одной строке */
  ```

### Особенности:
- Комментарии не могут быть вложенными
- Комментарии игнорируются внутри строковых литералов (компилятор не распознает `//` или `/*` внутри кавычек)
- Комментарии удаляются на этапе чтения исходного файла, до лексического анализа

## 11. ИДЕНТИФИКАТОРЫ

### Правила именования:
- Идентификаторы могут содержать только латинские буквы (a-z, A-Z)
- Максимальная длина идентификатора: 16 символов
- Регистр букв имеет значение (case-sensitive)

### Типы идентификаторов:
- **V** (Variable) - переменная
- **F** (Function) - пользовательская функция
- **S** (Standard) - стандартная функция
- **P** (Parameter) - параметр функции
- **L** (Literal) - литерал
- **ID** - общий идентификатор

## 12. СТРУКТУРА ПРОГРАММЫ

### Общая структура:
```
[<объявления_функций>]

main[
    <тело_программы>
]
```

### Объявление функции:
```
<тип_возврата> function <имя>(<параметры>)
[
    <тело_функции>
    return <значение>;  // для функций с возвращаемым значением
    return;              // для proc функций
]
```

### Объявление proc функции:
```
proc function <имя>(<параметры>)
[
    <тело_функции>
    return;
]
```

## 13. ЛЕКСЕМЫ (LEXEMES)

### Классы лексем:
- **LEX_SEPARATORS** ('S') - разделители
- **LEX_ID_TYPE** ('t') - тип идентификатора (number, line, char)
- **LEX_ID** ('i') - идентификатор
- **LEX_LITERAL** ('l') - литерал
- **LEX_FUNCTION** ('f') - ключевое слово function
- **LEX_MAIN** ('m') - ключевое слово main
- **LEX_VAR** ('n') - ключевое слово new
- **LEX_VOID** ('p') - ключевое слово proc
- **LEX_RETURN** ('e') - ключевое слово return
- **LEX_WRITE** ('o') - ключевое слово output
- **LEX_NEWLINE** ('^') - ключевое слово nextline
- **LEX_CONDITION** ('?') - ключевое слово is:
- **LEX_ISTRUE** ('w') - ключевое слово istrue
- **LEX_ISFALSE** ('r') - ключевое слово isfalse
- **LEX_CYCLE** ('c') - ключевое слово do
- **LEX_LITERAL_HEX** ('h') - шестнадцатеричный литерал

### Операторы (лексемы):
- **LEX_PLUS** ('+') - сложение
- **LEX_MINUS** ('-') - вычитание
- **LEX_STAR** ('*') - умножение
- **LEX_DIRSLASH** ('/') - деление
- **LEX_PERSENT** ('%') - остаток от деления
- **LEX_EQUAL** ('=') - присваивание
- **LEX_MORE** ('>') - больше
- **LEX_LESS** ('<') - меньше
- **LEX_EQUALS** ('&') - равно
- **LEX_NOTEQUALS** ('!') - не равно
- **LEX_MOREEQUALS** ('~') - больше или равно
- **LEX_LESSEQUALS** ('@') - меньше или равно

### Разделители (лексемы):
- **LEX_SEPARATOR** (';') - точка с запятой
- **LEX_COMMA** (',') - запятая
- **LEX_LEFTBRACE** ('[') - открывающая квадратная скобка
- **LEX_BRACELET** (']') - закрывающая квадратная скобка
- **LEX_LEFTHESIS** ('(') - открывающая круглая скобка
- **LEX_RIGHTTHESIS** (')') - закрывающая круглая скобка
- **LEX_DIEZ** ('#') - решетка

## 14. СЕМАНТИЧЕСКИЕ ПРАВИЛА

### Проверки типов:
1. При присваивании типы левой и правой части должны совпадать
2. Операторы сравнения работают только с типом `number`
3. Арифметические операции работают только с типом `number`
4. Для строковых переменных нельзя использовать арифметические операции (+, -, *)
5. Деление на ноль проверяется семантически

### Проверки функций:
1. Количество параметров при вызове должно совпадать с объявлением
2. Типы параметров должны совпадать с объявлением
3. Максимальное количество параметров: 3
4. Тип возвращаемого значения функции должен совпадать с типом в return

### Проверки переменных:
1. Переменные должны быть объявлены с ключевым словом `new`
2. Переменные должны иметь тип при объявлении
3. Идентификаторы должны быть уникальными в своей области видимости

## 15. ПРИМЕРЫ ПРОГРАММ

### Пример 1: Простая программа
```
// Простая программа для сложения двух чисел
main[
    new number x = 5;  // Первое число
    new number y = 10; // Второе число
    new number sum;    // Результат
    
    /* Вычисляем сумму */
    sum = x + y;
    output sum;
    nextline;
]
```

### Пример 2: Функция с условием
```
/* Функция для нахождения максимального из двух чисел */
number function max(number x, number y)
[
    new number res;
    is: x > y #  // Проверяем условие
    istrue [res = x;]   // Если x больше
    isfalse [res = y;]# // Если y больше
    return res;
]

main[
    new number a = 5;
    new number b = 10;
    new number result;
    result = max(a, b);  // Вызываем функцию
    output result;
    nextline;
]
```

### Пример 3: Работа со строками
```
main[
    new line str1 = "Hello";
    new line str2 = "World";
    new line combined;
    combined = concat(str1, str2);
    output combined;
    nextline;
]
```

### Пример 4: Цикл
```
main[
    new number i = 0;
    is: i < 10 #
    do [
        output i;
        output " ";
        i = i + 1;
    ]#
    nextline;
]
```

### Пример 5: Условный оператор
```
main[
    new number x = 5;
    new number y = 10;
    is: x > y #
    istrue [output "x больше y";]
    isfalse [output "x не больше y";]#
    nextline;
]
```

## 16. ОСОБЕННОСТИ РЕАЛИЗАЦИИ

### Генерация кода:
- Язык компилируется в ассемблерный код (MASM)
- Используется стековая машина для вычисления выражений
- Поддерживается обратная польская нотация для арифметических выражений
- Генерируется 32-битный ассемблерный код

### Обработка ошибок:
- Лексический анализ с проверкой синтаксиса
- Синтаксический анализ (MFST - модифицированная формальная система)
- Семантический анализ с проверкой типов
- Преобразование в польскую нотацию
- Генерация кода

### Ограничения:
- Максимальная длина строки: 255 символов
- Максимальная длина идентификатора: 16 символов
- Максимальное количество параметров функции: 3
- Диапазон чисел: -32768 до 32767 (short)
- Максимальный размер таблицы лексем: 4096
- Максимальный размер таблицы идентификаторов: 4096

## 17. ГРАММАТИКА

### Основные правила:
- Программа состоит из объявлений функций и главной функции main
- Функции объявляются до main
- Все инструкции заканчиваются точкой с запятой
- Блоки кода обрамляются квадратными скобками `[...]`
- Параметры функций разделяются запятыми
- Условия и циклы используют символ `#` как разделитель

### BNF-подобная структура:
```
<программа> ::= [<объявление_функции>]* main[<тело>]

<объявление_функции> ::= <тип> function <id>(<параметры>)[<тело>]
                        | proc function <id>(<параметры>)[<тело>]

<параметры> ::= <параметр>[,<параметр>]*
<параметр> ::= <тип> <id>

<тип> ::= number | line | char

<тело> ::= <инструкция>*
<инструкция> ::= <объявление> | <присваивание> | <условие> | <цикл> | <вызов_функции> | <return> | <output> | <nextline>

<объявление> ::= new <тип> <id> [= <выражение>];

<присваивание> ::= <id> = <выражение>;

<условие> ::= is: <выражение> <оператор> <выражение> # istrue [<тело>] isfalse [<тело>] #

<цикл> ::= is: <id> <оператор> <выражение> # do [<тело>] #

<выражение> ::= <терм> | <выражение> <арифм_оп> <терм>
<терм> ::= <id> | <литерал> | (<выражение>) | <вызов_функции>

<оператор> ::= > | < | & | ! | ~ | @
<арифм_оп> ::= + | - | * | / | %
```

---

**Примечание**: Это полное описание структуры языка на основе анализа исходного кода компилятора. Все элементы языка реализованы и поддерживаются компилятором.

